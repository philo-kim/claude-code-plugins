# /ddd analyze

Analyze an existing codebase and generate DDD management artifacts.

## Purpose

This command introduces a DDD governance system to codebases that were built without DDD in mind. It does NOT generate application code - it only creates management artifacts for DDD oversight.

## What This Command Does

1. **Scans the project** - Auto-detect language, framework, and architecture
2. **Identifies domain layer** - Find where domain logic lives
3. **Detects DDD elements** - Aggregate Roots, Entities, Value Objects, Domain Events
4. **Infers Bounded Contexts** - Map module boundaries to contexts
5. **Generates management files**:
   - `.ddd.yaml` - Project DDD configuration and inferred model
   - `shared/glossary.yaml` - Domain terms extracted from code
   - `shared/context-map.md` - Bounded Context relationship diagram

## Usage

```
/ddd analyze [path]
```

- `path` (optional): Directory to analyze. Defaults to current directory.

## Execution Steps

### Step 1: Project Scan

Detect the project characteristics:

```markdown
## Project Detection

- **Language**: [TypeScript | Java | Kotlin | Python | Go | C#]
- **Framework**: [NestJS | Spring Boot | Django | etc.]
- **Architecture**: [Layered | Hexagonal | Clean | Unclear]
- **Package Structure**: [by-feature | by-layer | mixed]
```

Look for indicators:
- `package.json`, `pom.xml`, `build.gradle`, `requirements.txt`, `go.mod`, `*.csproj`
- Framework-specific files and configurations
- Directory structure patterns

### Step 2: Domain Layer Identification

Search for domain-related code:

1. Look for directories named: `domain`, `model`, `entities`, `core`
2. Look for classes with domain patterns:
   - Classes with business methods (not just getters/setters)
   - Classes representing business concepts
   - Repository interfaces (not implementations)
3. Exclude infrastructure concerns:
   - HTTP controllers
   - Database entities with ORM annotations only
   - External service clients

### Step 3: DDD Element Detection

For each potential domain class, classify:

| Type | Detection Criteria |
|------|-------------------|
| **Aggregate Root** | Has identity, contains other entities, has business methods |
| **Entity** | Has identity, belongs to an aggregate |
| **Value Object** | No identity (compared by value), immutable |
| **Domain Event** | Named as past-tense action, contains event data |
| **Domain Service** | Stateless, contains domain logic across aggregates |
| **Repository** | Interface for aggregate persistence |

Confidence levels:
- **High**: Clear patterns, naming conventions match
- **Medium**: Some indicators present
- **Low**: Inferred from context

### Step 4: Bounded Context Inference

Group related domain elements:

1. Analyze module/package boundaries
2. Look for shared dependencies between classes
3. Identify communication patterns (direct calls vs events)
4. Map to logical business domains

### Step 5: Generate Management Files

#### `.ddd.yaml`

```yaml
# DDD Project Configuration
# Generated by /ddd analyze on [date]
# Review and adjust as needed

project: [project-name]
language: [detected-language]
framework: [detected-framework]
architecture: [detected-architecture]

paths:
  domain: [detected-domain-path]
  application: [detected-application-path]
  infrastructure: [detected-infrastructure-path]

bounded_contexts:
  - name: [ContextName]
    path: [path/to/context]
    aggregates:
      - name: [AggregateName]
        root: [path/to/AggregateRoot]
        entities: [list of entity paths]
        value_objects: [list of VO paths]
        events: [list of event paths]

# Health check configuration
health:
  thresholds:
    aggregate_max_entities: 3
    service_max_lines: 300
    service_max_methods: 15
    event_coverage_min: 50

  ignore:
    - "**/test/**"
    - "**/tests/**"
    - "**/__tests__/**"
    - "**/migrations/**"

glossary_path: shared/glossary.yaml
context_map_path: shared/context-map.md
```

#### `shared/glossary.yaml`

```yaml
# Domain Glossary - Ubiquitous Language
# Generated by /ddd analyze on [date]
# Status: needs_review - Please review and refine definitions

domain: [business-domain]
extracted_from: [analyzed-path]

terms:
  [TermName]:
    definition: "[Auto-extracted definition or 'Definition needed']"
    found_in:
      - [file-path-1]
      - [file-path-2]
    aliases: [list of similar terms found]
    status: needs_review  # or: approved, deprecated

  # ... more terms
```

#### `shared/context-map.md`

```markdown
# Bounded Context Map

Generated by `/ddd analyze` on [date]

## Contexts

### [Context A]
- **Responsibility**: [inferred responsibility]
- **Key Aggregates**: [list]
- **Path**: [path]

### [Context B]
- **Responsibility**: [inferred responsibility]
- **Key Aggregates**: [list]
- **Path**: [path]

## Relationships

[Context A] --> [Context B]: [relationship type]
- Type: [Shared Kernel | Customer-Supplier | Conformist | ACL | OHS | PL]
- Communication: [Direct | Events | API]

## Diagram

\`\`\`
┌─────────────┐     ┌─────────────┐
│  Context A  │────>│  Context B  │
│             │     │             │
│ - Aggregate │     │ - Aggregate │
│ - Aggregate │     │ - Aggregate │
└─────────────┘     └─────────────┘
\`\`\`
```

## Output Format

After analysis, display:

```markdown
## Codebase Analysis Results

### Detected Structure
- **Language**: [language]
- **Framework**: [framework]
- **Architecture**: [architecture-type]
- **Bounded Contexts**: [count] detected

### Domain Model Map

| Type | Name | Location | Confidence |
|------|------|----------|------------|
| Aggregate Root | [Name] | [path] | High |
| Entity | [Name] | [path] | Medium |
| Value Object | (none found) | - | - |
| Domain Event | (none found) | - | - |

### Generated DDD Management Files
✅ `.ddd.yaml` - Project configuration
✅ `shared/glossary.yaml` - Glossary ([N] terms extracted)
✅ `shared/context-map.md` - Context Map

### Immediate Concerns
1. ❌ [Issue]: [Description]
2. ⚠️ [Warning]: [Description]

### Next Steps
→ Run `/ddd glossary review` to refine extracted terms
→ Run `/ddd health` to start continuous monitoring
→ Edit `.ddd.yaml` to adjust detected boundaries
```

## Important Notes

- This command does NOT generate application code
- Generated files require human review and refinement
- Confidence levels indicate detection certainty
- Run `/ddd health` after review to establish baseline metrics
